# JWT Token Guide for WebSocket Gateway

## Overview

The WebSocket gateway requires a JWT (JSON Web Token) for authentication. The token is generated by your Laravel backend when users log in.

## How Tokens Work

1. **User logs in** → Laravel generates JWT token
2. **Mobile app receives token** → Stores it securely
3. **Mobile app connects to WebSocket** → Sends token in query parameter
4. **Gateway validates token** → With Laravel or locally (if configured)

## Token Format

JWT tokens have three parts separated by dots:
```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
```

## How to Provide Token

### Option 1: Query Parameter (Recommended)

The token is provided in the WebSocket URL query parameter:

```javascript
const token = 'your-jwt-token-here';
const ws = new WebSocket(`ws://localhost:8080?token=${token}`);
```

**Example:**
```javascript
const token = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...';
const ws = new WebSocket(`ws://localhost:8080?token=${token}`);
```

### Option 2: Authorization Header (If upgraded from HTTP)

If the WebSocket connection is upgraded from an HTTP request, you can also use the Authorization header:

```javascript
// Note: This works only if the connection is upgraded from HTTP
// Most WebSocket libraries don't support custom headers directly
const ws = new WebSocket('ws://localhost:8080', {
  headers: {
    'Authorization': `Bearer ${token}`
  }
});
```

**Note:** Most browsers and WebSocket libraries don't support custom headers. Use query parameters instead.

## Laravel Token Generation

### 1. Install JWT Package (if not already installed)

```bash
composer require tymon/jwt-auth
```

### 2. Configure JWT in Laravel

**config/jwt.php** (or add to config/services.php):
```php
return [
    'secret' => env('JWT_SECRET', 'your-secret-key'),
    'algorithm' => env('JWT_ALGORITHM', 'HS256'),
    'issuer' => env('JWT_ISSUER', 'laravel-backend'),
    // ... other config
];
```

**Update .env:**
```env
JWT_SECRET=your-super-secret-key-change-this-in-production
JWT_ALGORITHM=HS256
JWT_ISSUER=laravel-backend
```

**Important:** The `JWT_SECRET` in Laravel must match the `JWT_SECRET` in the Node.js gateway `.env` file!

### 3. Generate Token on Login

**Example Laravel Login Controller:**
```php
<?php

namespace App\Http\Controllers\Auth;

use App\Http\Controllers\Controller;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;
use Tymon\JWTAuth\Facades\JWTAuth;

class LoginController extends Controller
{
    public function login(Request $request)
    {
        $credentials = $request->validate([
            'email' => 'required|email',
            'password' => 'required',
        ]);

        if (!Auth::attempt($credentials)) {
            return response()->json([
                'success' => false,
                'message' => 'Invalid credentials',
            ], 401);
        }

        $user = Auth::user();
        
        // Generate JWT token
        $token = JWTAuth::fromUser($user);
        
        // Or using custom claims
        $token = JWTAuth::customClaims([
            'user_id' => $user->id,
            'email' => $user->email,
            'iss' => 'laravel-backend', // Issuer
            'iat' => now()->timestamp,  // Issued at
            'exp' => now()->addHours(24)->timestamp, // Expiration
        ])->fromUser($user);

        return response()->json([
            'success' => true,
            'token' => $token,
            'user' => [
                'id' => $user->id,
                'email' => $user->email,
                'name' => $user->name,
            ],
        ]);
    }
}
```

### 4. Token Response Format

Laravel should return:
```json
{
  "success": true,
  "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "user": {
    "id": 123,
    "email": "user@example.com",
    "name": "John Doe"
  }
}
```

## Mobile App Integration Examples

### JavaScript/React Native

```javascript
import AsyncStorage from '@react-native-async-storage/async-storage';

class WebSocketService {
  constructor() {
    this.ws = null;
    this.token = null;
  }

  async connect() {
    // Get token from storage (set after login)
    this.token = await AsyncStorage.getItem('auth_token');
    
    if (!this.token) {
      throw new Error('No authentication token found');
    }

    // Connect with token in query parameter
    const wsUrl = `ws://your-domain.com:8080?token=${this.token}`;
    this.ws = new WebSocket(wsUrl);

    this.ws.onopen = () => {
      console.log('Connected to WebSocket gateway');
    };

    this.ws.onmessage = (event) => {
      const message = JSON.parse(event.data);
      console.log('Received:', message);
      this.handleMessage(message);
    };

    this.ws.onerror = (error) => {
      console.error('WebSocket error:', error);
    };

    this.ws.onclose = () => {
      console.log('WebSocket closed');
    };
  }

  sendMessage(action, data) {
    if (this.ws && this.ws.readyState === WebSocket.OPEN) {
      this.ws.send(JSON.stringify({
        action: action,
        data: data
      }));
    }
  }

  handleMessage(message) {
    switch (message.type) {
      case 'connected':
        console.log('Connection confirmed:', message);
        break;
      case 'response':
        console.log('Action response:', message);
        break;
      case 'error':
        console.error('Error:', message.message);
        break;
      default:
        console.log('Unknown message type:', message);
    }
  }

  disconnect() {
    if (this.ws) {
      this.ws.close();
      this.ws = null;
    }
  }
}

// Usage
const wsService = new WebSocketService();
await wsService.connect();
wsService.sendMessage('start_charging', { charger_id: 'CP001' });
```

### Android (Java/Kotlin)

```kotlin
import okhttp3.OkHttpClient
import okhttp3.Request
import okhttp3.WebSocket
import okhttp3.WebSocketListener

class WebSocketManager {
    private var webSocket: WebSocket? = null
    private val client = OkHttpClient()
    
    fun connect(token: String) {
        val request = Request.Builder()
            .url("ws://your-domain.com:8080?token=$token")
            .build()
            
        webSocket = client.newWebSocket(request, object : WebSocketListener() {
            override fun onOpen(webSocket: WebSocket, response: Response) {
                Log.d("WebSocket", "Connected")
            }
            
            override fun onMessage(webSocket: WebSocket, text: String) {
                Log.d("WebSocket", "Message: $text")
                // Handle message
            }
            
            override fun onFailure(webSocket: WebSocket, t: Throwable, response: Response?) {
                Log.e("WebSocket", "Error: ${t.message}")
            }
        })
    }
    
    fun sendMessage(action: String, data: Map<String, Any>) {
        val message = JSONObject().apply {
            put("action", action)
            put("data", JSONObject(data))
        }
        webSocket?.send(message.toString())
    }
}

// Usage
val token = "your-jwt-token"
val wsManager = WebSocketManager()
wsManager.connect(token)
wsManager.sendMessage("start_charging", mapOf("charger_id" to "CP001"))
```

### iOS (Swift)

```swift
import Foundation
import Starscream

class WebSocketManager: WebSocketDelegate {
    var socket: WebSocket?
    var token: String?
    
    func connect(token: String) {
        self.token = token
        let urlString = "ws://your-domain.com:8080?token=\(token)"
        guard let url = URL(string: urlString) else { return }
        
        var request = URLRequest(url: url)
        request.timeoutInterval = 5
        
        socket = WebSocket(request: request)
        socket?.delegate = self
        socket?.connect()
    }
    
    func didReceive(event: WebSocketEvent, client: WebSocketClient) {
        switch event {
        case .connected(let headers):
            print("WebSocket connected: \(headers)")
        case .disconnected(let reason, let code):
            print("WebSocket disconnected: \(reason) with code: \(code)")
        case .text(let string):
            print("Received text: \(string)")
            handleMessage(string)
        case .error(let error):
            print("WebSocket error: \(error?.localizedDescription ?? "Unknown")")
        default:
            break
        }
    }
    
    func sendMessage(action: String, data: [String: Any]) {
        let message: [String: Any] = [
            "action": action,
            "data": data
        ]
        
        if let jsonData = try? JSONSerialization.data(withJSONObject: message),
           let jsonString = String(data: jsonData, encoding: .utf8) {
            socket?.write(string: jsonString)
        }
    }
    
    func handleMessage(_ message: String) {
        // Parse and handle message
    }
}

// Usage
let token = "your-jwt-token"
let wsManager = WebSocketManager()
wsManager.connect(token: token)
wsManager.sendMessage(action: "start_charging", data: ["charger_id": "CP001"])
```

## Testing with curl/wscat

### Using wscat (WebSocket client)

```bash
# Install wscat
npm install -g wscat

# Connect with token
wscat -c "ws://localhost:8080?token=YOUR_JWT_TOKEN"

# Once connected, send message:
{"action": "start_charging", "data": {"charger_id": "CP001"}}
```

### Using Browser Console

```javascript
const token = 'your-jwt-token-here';
const ws = new WebSocket(`ws://localhost:8080?token=${token}`);

ws.onopen = () => {
  console.log('Connected!');
  ws.send(JSON.stringify({
    action: 'start_charging',
    data: { charger_id: 'CP001' }
  }));
};

ws.onmessage = (event) => {
  console.log('Received:', JSON.parse(event.data));
};
```

## Token Configuration Checklist

### Laravel (.env)
```env
JWT_SECRET=your-super-secret-key
JWT_ALGORITHM=HS256
JWT_ISSUER=laravel-backend
```

### Node.js Gateway (.env)
```env
JWT_SECRET=your-super-secret-key  # MUST MATCH LARAVEL!
JWT_ALGORITHM=HS256
JWT_ISSUER=laravel-backend
LARAVEL_API_URL=http://localhost:8000
```

**Important:** The `JWT_SECRET` must be **exactly the same** in both Laravel and Node.js gateway!

## Token Validation Flow

1. **Mobile app connects** with token in query parameter
2. **Gateway extracts token** from URL
3. **Gateway validates token:**
   - First tries local validation (fast)
   - If local validation fails, calls Laravel API
4. **If valid:** Connection accepted
5. **If invalid:** Connection rejected with error code 1008

## Troubleshooting

### Error: "No token provided"
- ✅ Check token is in query parameter: `ws://host:port?token=YOUR_TOKEN`
- ✅ Verify token is not empty
- ✅ Check token is URL-encoded if it contains special characters

### Error: "Invalid authentication token"
- ✅ Verify JWT_SECRET matches in Laravel and Gateway
- ✅ Check token hasn't expired
- ✅ Verify token issuer matches
- ✅ Check Laravel API is accessible for token validation

### Error: "User ID mismatch"
- ✅ Verify token contains user ID
- ✅ Check token payload structure matches expected format

## Security Best Practices

1. **Always use HTTPS/WSS** in production
2. **Store tokens securely** (use secure storage, not localStorage)
3. **Implement token refresh** before expiration
4. **Use short-lived tokens** (1-24 hours)
5. **Rotate JWT_SECRET** regularly
6. **Validate tokens on every request**
7. **Log authentication failures** for security monitoring

## Example Complete Flow

```javascript
// 1. User logs in
const loginResponse = await fetch('http://laravel:8000/api/login', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({
    email: 'user@example.com',
    password: 'password123'
  })
});

const { token, user } = await loginResponse.json();

// 2. Store token securely
await AsyncStorage.setItem('auth_token', token);

// 3. Connect to WebSocket with token
const ws = new WebSocket(`ws://gateway:8080?token=${token}`);

// 4. Send messages
ws.onopen = () => {
  ws.send(JSON.stringify({
    action: 'start_charging',
    data: { charger_id: 'CP001' }
  }));
};

// 5. Handle responses
ws.onmessage = (event) => {
  const message = JSON.parse(event.data);
  console.log('Response:', message);
};
```

---

*Last Updated: 2025-01-29*

